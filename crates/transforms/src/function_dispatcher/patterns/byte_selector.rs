use crate::{Error, Result};
use azoth_core::decoder::Instruction;
use azoth_core::detection::{DispatcherInfo, ExtractionPattern, FunctionSelector};
use azoth_core::Opcode;
use petgraph::graph::NodeIndex;
use rand::{rngs::StdRng, RngCore};
use sha3::{Digest, Keccak256};
use std::collections::{HashMap, HashSet};
use tracing::debug;

/// Number of bytes written into each dispatcher PUSH immediate.
pub const SELECTOR_TOKEN_LEN: usize = 4;
/// Maximum selectors supported when using single-byte discriminators.
pub const MAX_SELECTOR_COUNT: usize = 256;

/// Groups a list of `(offset, opcode, optional immediate)` edits by CFG node.
///
/// Each entry describes how to mutate the instructions inside that block:
/// replace the instruction at `offset` with `opcode` and (if provided) update
/// its immediate to the supplied hex string.
pub type PatchPlan = HashMap<NodeIndex, Vec<(usize, Opcode, Option<String>)>>;

pub struct ByteSelectorPattern;

impl ByteSelectorPattern {
    /// Builds the selectorâ†’token mapping used by the byte-selector pattern.
    ///
    /// Every selector receives a deterministic single-byte discriminator derived from
    /// the provided RNG secret. The byte is left-padded to `SELECTOR_TOKEN_LEN` so the
    /// dispatcher keeps using PUSH4 comparisons.
    pub fn generate_mapping(
        selectors: &[FunctionSelector],
        rng: &mut StdRng,
    ) -> Result<HashMap<u32, Vec<u8>>> {
        if selectors.is_empty() {
            return Ok(HashMap::new());
        }

        let mut secret = [0u8; 32];
        rng.fill_bytes(&mut secret);

        let mut mapping = HashMap::with_capacity(selectors.len());
        let mut used_bytes = HashSet::with_capacity(selectors.len());

        for selector in selectors {
            let selector_byte =
                derive_unique_selector_byte(selector.selector, &secret, &mut used_bytes)?;

            let mut token = vec![0u8; SELECTOR_TOKEN_LEN];
            token[SELECTOR_TOKEN_LEN - 1] = selector_byte;
            mapping.insert(selector.selector, token);
        }

        Ok(mapping)
    }

    /// Produces the instruction edits required to replace the canonical calldata
    /// extraction (`CALLDATALOAD; PUSH1 0xe0; SHR`) with the byte-based pattern
    /// (`CALLDATALOAD; PUSH1 0x03; BYTE`).
    pub fn plan_extraction_patches(
        runtime: &[Instruction],
        index_by_pc: &HashMap<usize, (NodeIndex, usize)>,
        info: &DispatcherInfo,
    ) -> Result<PatchPlan> {
        let Some((start, _, pattern)) = azoth_core::detection::find_extraction_pattern(runtime)
        else {
            debug!("Selector extraction pattern not found; skipping byte-selector rewrite");
            return Ok(HashMap::new());
        };

        if pattern != info.extraction_pattern {
            debug!(
                "Extraction pattern mismatch (detected {:?}, runtime {:?}); proceeding with runtime pattern",
                info.extraction_pattern, pattern
            );
        }

        let instruction_plan: Vec<(usize, Opcode, Option<String>)> = match pattern {
            ExtractionPattern::Standard => vec![
                (start + 2, Opcode::PUSH(1), Some("03".to_string())),
                (start + 3, Opcode::BYTE, None),
            ],
            ExtractionPattern::Newer => vec![
                (start + 1, Opcode::PUSH(1), Some("03".to_string())),
                (start + 2, Opcode::BYTE, None),
            ],
            other => {
                debug!(
                    "Unsupported extraction pattern {:?}; leaving dispatcher preamble untouched",
                    other
                );
                return Ok(HashMap::new());
            }
        };

        plan_instruction_patches(&instruction_plan, runtime, index_by_pc)
    }

    /// Produces the instruction edits that swap each dispatcher `PUSH4 <selector>`
    /// for the obfuscated token generated by `generate_mapping`.
    pub fn plan_dispatcher_patches(
        runtime: &[Instruction],
        index_by_pc: &HashMap<usize, (NodeIndex, usize)>,
        info: &DispatcherInfo,
        mapping: &HashMap<u32, Vec<u8>>,
    ) -> Result<PatchPlan> {
        let mut per_block: PatchPlan = HashMap::new();

        for selector in &info.selectors {
            let instruction = runtime.get(selector.instruction_index).ok_or_else(|| {
                Error::Generic(format!(
                    "dispatcher: selector index {} out of bounds",
                    selector.instruction_index
                ))
            })?;

            let (node, offset) = index_by_pc.get(&instruction.pc).ok_or_else(|| {
                Error::Generic(format!(
                    "dispatcher: instruction at pc {} not found in CFG",
                    instruction.pc
                ))
            })?;

            let token = mapping.get(&selector.selector).ok_or_else(|| {
                Error::Generic(format!(
                    "dispatcher: missing token for selector 0x{:08x}",
                    selector.selector
                ))
            })?;

            let push_size = token.len();
            if push_size == 0 || push_size > 32 {
                return Err(Error::Generic(format!(
                    "dispatcher: token for selector 0x{:08x} has invalid length {}",
                    selector.selector, push_size
                )));
            }

            per_block.entry(*node).or_default().push((
                *offset,
                Opcode::PUSH(push_size as u8),
                Some(hex::encode(token)),
            ));
        }

        Ok(per_block)
    }
}

/// Converts a list of `(instruction_index, opcode, immediate)` edits into
/// a block-indexed `PatchPlan` using the CFG node/offset lookup table.
fn plan_instruction_patches(
    plan: &[(usize, Opcode, Option<String>)],
    runtime: &[Instruction],
    index_by_pc: &HashMap<usize, (NodeIndex, usize)>,
) -> Result<PatchPlan> {
    let mut per_block: PatchPlan = HashMap::new();

    for (instruction_index, opcode, imm) in plan {
        let instruction = runtime.get(*instruction_index).ok_or_else(|| {
            Error::Generic(format!(
                "dispatcher: extraction instruction index {} out of bounds",
                instruction_index
            ))
        })?;

        let (node, offset) = index_by_pc.get(&instruction.pc).ok_or_else(|| {
            Error::Generic(format!(
                "dispatcher: extraction instruction at pc {} not present in CFG",
                instruction.pc
            ))
        })?;

        per_block
            .entry(*node)
            .or_default()
            .push((*offset, *opcode, imm.clone()));
    }

    Ok(per_block)
}

fn derive_unique_selector_byte(
    selector: u32,
    secret: &[u8; 32],
    used_bytes: &mut HashSet<u8>,
) -> Result<u8> {
    const MAX_ATTEMPTS: u32 = 1_000;

    let selector_bytes = selector.to_be_bytes();

    for counter in 0..MAX_ATTEMPTS {
        let mut hasher = Keccak256::new();
        hasher.update(secret);
        hasher.update(selector_bytes);
        hasher.update(counter.to_be_bytes());
        let hash = hasher.finalize();

        let candidate = hash[hash.len() - 1];

        if candidate == selector_bytes[selector_bytes.len() - 1] {
            continue;
        }

        if used_bytes.insert(candidate) {
            return Ok(candidate);
        }
    }

    Err(Error::Generic(
        "dispatcher: failed to derive unique selector token".into(),
    ))
}
