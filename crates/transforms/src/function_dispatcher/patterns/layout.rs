//! Layout and bytecode synthesis.
//!
//! This module is responsible for taking the abstract blueprint generated by the blueprint
//! module and synthesizing it into concrete EVM bytecode instructions that are inserted
//! into the control flow graph. The layout process transforms the high-level obfuscation
//! plan into actual executable code that implements the multi-tier dispatcher pattern.

use super::blueprint::{ControllerPatternConfig, DispatcherBlueprint, TierAssignment};
use super::controller::{
    generate_byte_extraction_instructions, generate_storage_check_instructions,
};
use crate::function_dispatcher::storage::StorageRoutingConfig;
use crate::function_dispatcher::token::generate_selector_token_mapping;
use crate::function_dispatcher::FunctionDispatcher;
use crate::Error;
use azoth_core::cfg_ir::{Block, BlockBody, BlockControl, CfgIrBundle};
use azoth_core::decoder::Instruction;
use azoth_core::detection::{DispatcherInfo, FunctionSelector};
use azoth_core::Opcode;
use petgraph::graph::NodeIndex;
use rand::rngs::StdRng;
use std::collections::HashMap;
use tracing::debug;

struct TierNodes {
    stub_pc: usize,
    #[allow(dead_code)]
    decoy_pc: usize,
}

/// Result produced when a dispatch layout has been synthesised.
pub struct LayoutPlan {
    pub mapping: HashMap<u32, Vec<u8>>,
    pub dispatcher_modified: bool,
    #[allow(dead_code)]
    pub routing: StorageRoutingConfig,
}

pub fn apply_layout_plan(
    dispatcher: &FunctionDispatcher,
    ir: &mut CfgIrBundle,
    runtime: &[Instruction],
    index_by_pc: &HashMap<usize, (NodeIndex, usize)>,
    dispatcher_info: &DispatcherInfo,
    rng: &mut StdRng,
    blueprint: &DispatcherBlueprint,
) -> crate::Result<Option<LayoutPlan>> {
    let mut next_pc = highest_pc(ir).saturating_add(1);

    let mut tiers: HashMap<usize, Vec<&TierAssignment>> = HashMap::new();
    for assignment in &blueprint.selectors {
        tiers
            .entry(assignment.tier_index)
            .or_default()
            .push(assignment);
    }

    let mut tier_nodes: HashMap<usize, TierNodes> = HashMap::new();
    for (tier_index, assignments) in tiers.iter() {
        if *tier_index == 0 {
            continue;
        }

        let Some(primary) = assignments.first() else {
            continue;
        };

        let target_pc = primary.selector.target_address as usize;
        let (target_node, _) = index_by_pc.get(&target_pc).ok_or_else(|| {
            Error::Generic(format!(
                "multi-tier: missing target pc 0x{target_pc:04x} in CFG mapping"
            ))
        })?;

        let target_node = *target_node;
        let (nodes, updated_pc) = create_tier_nodes(ir, next_pc, target_node)?;
        next_pc = updated_pc;
        tier_nodes.insert(*tier_index, nodes);
    }

    if let Some((start, end)) = ir.runtime_bounds {
        if next_pc > end {
            ir.runtime_bounds = Some((start, next_pc));
        }
    }

    // Generate 4-byte token mapping for selectors (preserves original extraction pattern)
    let mapping = generate_selector_token_mapping(&dispatcher_info.selectors, rng)?;

    // Apply dispatcher patches: replace original selectors with derived tokens
    let mut dispatcher_modified =
        dispatcher.apply_dispatcher_patches(ir, runtime, index_by_pc, dispatcher_info, &mapping)?;

    let mut selector_entry_pcs = HashMap::new();
    for assignment in &blueprint.selectors {
        let target_pc = assignment.selector.target_address as usize;
        let fallback_pc = target_pc;
        let stub_pc = tier_nodes
            .get(&assignment.tier_index)
            .map(|nodes| nodes.stub_pc)
            .unwrap_or(target_pc);

        let pattern_config = blueprint.controller_patterns.get(&assignment.tier_index);
        let (controller_pc, updated_pc) = create_selector_controller(
            ir,
            next_pc,
            stub_pc,
            fallback_pc,
            pattern_config,
            assignment.selector.selector,
        )?;
        next_pc = updated_pc;
        selector_entry_pcs.insert(assignment.selector.selector, controller_pc);
    }

    // Update runtime bounds to include all newly created blocks
    if let Some((start, end)) = ir.runtime_bounds {
        if next_pc > end {
            ir.runtime_bounds = Some((start, next_pc));
        }
    }

    let mut edits = Vec::new();
    for assignment in &blueprint.selectors {
        let Some(&controller_pc) = selector_entry_pcs.get(&assignment.selector.selector) else {
            continue;
        };

        if let Some(instr_idx) = locate_target_push(runtime, &assignment.selector) {
            let instr = &runtime[instr_idx];
            let pc = instr.pc;
            let (node, _) = index_by_pc.get(&pc).ok_or_else(|| {
                Error::Generic(format!(
                    "multi-tier: dispatcher instruction at pc 0x{pc:04x} missing from CFG"
                ))
            })?;

            let push_width = match instr.op {
                Opcode::PUSH(width) => width,
                _ => continue,
            };
            let formatted = format!(
                "{:0width$x}",
                controller_pc,
                width = push_width as usize * 2
            );
            edits.push((*node, pc, instr.op, Some(formatted)));
        } else {
            debug!(
                selector = format_args!("0x{:08x}", assignment.selector.selector),
                "multi-tier: unable to locate dispatcher target push"
            );
        }
    }

    if !edits.is_empty() && dispatcher.apply_instruction_replacements(ir, edits)? {
        dispatcher_modified = true;
    }

    Ok(Some(LayoutPlan {
        mapping,
        dispatcher_modified,
        routing: blueprint.routing.clone(),
    }))
}

fn highest_pc(ir: &CfgIrBundle) -> usize {
    ir.cfg
        .node_indices()
        .filter_map(|idx| match &ir.cfg[idx] {
            Block::Body(body) => body
                .instructions
                .last()
                .map(|instr| instr.pc + instr.byte_size()),
            _ => None,
        })
        .max()
        .unwrap_or(0)
}

fn minimal_push_width(value: usize) -> u8 {
    for width in 1..=32 {
        let max = if width == 32 {
            usize::MAX
        } else {
            (1usize << (width * 8)) - 1
        };
        if value <= max {
            return width as u8;
        }
    }
    32
}

fn format_immediate(value: u128, width: u8) -> String {
    format!("{:0width$x}", value, width = width as usize * 2)
}

fn create_tier_nodes(
    ir: &mut CfgIrBundle,
    mut next_pc: usize,
    target_node: NodeIndex,
) -> crate::Result<(TierNodes, usize)> {
    let target_pc = match &ir.cfg[target_node] {
        Block::Body(body) => body.start_pc,
        _ => {
            return Err(Error::Generic(
                "multi-tier: target node is not a body block".into(),
            ))
        }
    };

    let invalid_start = next_pc;
    let invalid_block = BlockBody {
        start_pc: invalid_start,
        instructions: vec![
            Instruction {
                pc: invalid_start,
                op: Opcode::JUMPDEST,
                imm: None,
            },
            Instruction {
                pc: invalid_start + 1,
                op: Opcode::INVALID,
                imm: None,
            },
        ],
        max_stack: 0,
        control: BlockControl::Terminal,
    };
    next_pc += 2;
    let invalid_node = ir.cfg.add_node(Block::Body(invalid_block));
    ir.pc_to_block.insert(invalid_start, invalid_node);
    ir.rebuild_edges_for_block(invalid_node)
        .map_err(|err| Error::CoreError(err.to_string()))?;

    let mut pc = next_pc;
    let decoy_start = pc;
    let invalid_width = minimal_push_width(invalid_start);
    let target_width = minimal_push_width(target_pc);
    let mut decoy_instructions = Vec::new();
    decoy_instructions.push(Instruction {
        pc,
        op: Opcode::JUMPDEST,
        imm: None,
    });
    pc += 1;

    decoy_instructions.push(Instruction {
        pc,
        op: Opcode::PUSH(1),
        imm: Some("01".to_string()),
    });
    pc += 2;

    decoy_instructions.push(Instruction {
        pc,
        op: Opcode::PUSH(1),
        imm: Some("00".to_string()),
    });
    pc += 2;

    decoy_instructions.push(Instruction {
        pc,
        op: Opcode::EQ,
        imm: None,
    });
    pc += 1;

    decoy_instructions.push(Instruction {
        pc,
        op: Opcode::PUSH(invalid_width),
        imm: Some(format_immediate(invalid_start as u128, invalid_width)),
    });
    pc += 1 + invalid_width as usize;

    decoy_instructions.push(Instruction {
        pc,
        op: Opcode::JUMPI,
        imm: None,
    });
    pc += 1;

    decoy_instructions.push(Instruction {
        pc,
        op: Opcode::PUSH(target_width),
        imm: Some(format_immediate(target_pc as u128, target_width)),
    });
    pc += 1 + target_width as usize;

    decoy_instructions.push(Instruction {
        pc,
        op: Opcode::JUMP,
        imm: None,
    });
    pc += 1;

    let decoy_block = BlockBody {
        start_pc: decoy_start,
        instructions: decoy_instructions,
        max_stack: 2,
        control: BlockControl::Unknown,
    };
    let decoy_node = ir.cfg.add_node(Block::Body(decoy_block));
    ir.pc_to_block.insert(decoy_start, decoy_node);
    ir.rebuild_edges_for_block(decoy_node)
        .map_err(|err| Error::CoreError(err.to_string()))?;

    next_pc = pc;

    let stub_start = next_pc;
    let stub_width = minimal_push_width(decoy_start);
    let stub_instructions = vec![
        Instruction {
            pc: stub_start,
            op: Opcode::JUMPDEST,
            imm: None,
        },
        Instruction {
            pc: stub_start + 1,
            op: Opcode::PUSH(stub_width),
            imm: Some(format_immediate(decoy_start as u128, stub_width)),
        },
        Instruction {
            pc: stub_start + 1 + 1 + stub_width as usize,
            op: Opcode::JUMP,
            imm: None,
        },
    ];
    let stub_block = BlockBody {
        start_pc: stub_start,
        instructions: stub_instructions,
        max_stack: 1,
        control: BlockControl::Unknown,
    };
    let stub_node = ir.cfg.add_node(Block::Body(stub_block));
    ir.pc_to_block.insert(stub_start, stub_node);
    ir.set_unconditional_jump(stub_node, decoy_node)
        .map_err(|err| Error::CoreError(err.to_string()))?;

    next_pc = stub_start + stub_width as usize + 3;

    Ok((
        TierNodes {
            stub_pc: stub_start,
            decoy_pc: decoy_start,
        },
        next_pc,
    ))
}

fn create_selector_controller(
    ir: &mut CfgIrBundle,
    mut next_pc: usize,
    stub_pc: usize,
    fallback_pc: usize,
    pattern_config: Option<&ControllerPatternConfig>,
    selector: u32,
) -> crate::Result<(usize, usize)> {
    let start_pc = next_pc;
    let mut instructions = Vec::new();

    instructions.push(Instruction {
        pc: next_pc,
        op: Opcode::JUMPDEST,
        imm: None,
    });
    next_pc += 1;

    // Optionally add byte extraction pattern at the start of the controller
    if let Some(config) = pattern_config {
        if config.use_byte_extraction {
            // Extract the byte index from the selector for comparison
            let selector_bytes = selector.to_be_bytes();
            let expected_byte = selector_bytes[config.byte_index as usize];

            // Calculate where the JUMPDEST will be after the byte extraction block
            // The block consists of:
            // - PUSH1 0x00 + CALLDATALOAD + PUSH1 index + BYTE + PUSH1 expected + EQ (9 bytes fixed)
            // - PUSH(match_width) + imm + JUMPI (variable: 1 + match_width + 1)
            // - PUSH(fallback_width) + imm + JUMP (variable: 1 + fallback_width + 1)
            //
            // We need to calculate match_width, but it depends on byte_match_pc which we're calculating.
            // Use iterative approach: start with PUSH1, check if sufficient, adjust if needed.
            let byte_fail_pc = fallback_pc;
            let fallback_width = minimal_push_width(byte_fail_pc);
            let mut match_width = 1u8;
            let byte_match_pc;

            loop {
                let byte_block_size =
                    9 + (1 + match_width as usize + 1) + (1 + fallback_width as usize + 1);
                let candidate_pc = next_pc + byte_block_size;
                let required_width = minimal_push_width(candidate_pc);

                if required_width <= match_width {
                    byte_match_pc = candidate_pc;
                    break;
                }
                match_width = required_width;
            }

            let (byte_instrs, updated_pc) = generate_byte_extraction_instructions(
                next_pc,
                config.byte_index,
                expected_byte,
                byte_match_pc,
                byte_fail_pc,
            );

            // Add byte extraction instructions
            for instr in byte_instrs {
                instructions.push(instr);
            }
            next_pc = updated_pc;

            // Add a JUMPDEST after byte extraction for the match path
            // This should now be at the correct address that the instructions expect
            instructions.push(Instruction {
                pc: next_pc,
                op: Opcode::JUMPDEST,
                imm: None,
            });
            next_pc += 1;

            // Verify our calculation was correct
            debug_assert_eq!(
                next_pc - 1,
                byte_match_pc,
                "byte extraction JUMPDEST mismatch"
            );
        }

        // Optionally add storage check pattern
        if config.use_storage_checks {
            let (storage_instrs, updated_pc) = generate_storage_check_instructions(
                next_pc,
                config.storage_slot,
                stub_pc,     // If storage is zero (default), go to stub (real path)
                fallback_pc, // If storage is non-zero, go to fallback
            );

            for instr in storage_instrs {
                instructions.push(instr);
            }
            next_pc = updated_pc;
        }
    }

    let fallback_width = minimal_push_width(fallback_pc);
    instructions.push(Instruction {
        pc: next_pc,
        op: Opcode::PUSH(fallback_width),
        imm: Some(format_immediate(fallback_pc as u128, fallback_width)),
    });
    next_pc += 1 + fallback_width as usize;

    instructions.push(Instruction {
        pc: next_pc,
        op: Opcode::JUMP,
        imm: None,
    });
    next_pc += 1;

    let block = BlockBody {
        start_pc,
        instructions: instructions.clone(),
        max_stack: 2,
        control: BlockControl::Unknown,
    };

    let node = ir.cfg.add_node(Block::Body(block));
    ir.pc_to_block.insert(start_pc, node);
    ir.rebuild_edges_for_block(node)
        .map_err(|err| Error::CoreError(err.to_string()))?;

    Ok((start_pc, next_pc))
}

fn locate_target_push(runtime: &[Instruction], selector: &FunctionSelector) -> Option<usize> {
    let target = selector.target_address as usize;
    for (idx, instr) in runtime
        .iter()
        .enumerate()
        .skip(selector.instruction_index + 1)
    {
        match instr.op {
            Opcode::JUMPI => break,
            Opcode::PUSH(_) | Opcode::PUSH0 => {
                if instr
                    .imm
                    .as_ref()
                    .and_then(|imm| usize::from_str_radix(imm, 16).ok())
                    == Some(target)
                {
                    return Some(idx);
                }
            }
            _ => {}
        }
    }
    None
}
